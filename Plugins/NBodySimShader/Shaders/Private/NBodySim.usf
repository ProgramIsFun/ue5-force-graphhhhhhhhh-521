

#include "/Engine/Private/Common.ush"


// Buffers
StructuredBuffer<float> Masses;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> Velocities;

// Settings
const uint NumBodies;
const float GravityConstant;
const float CameraAspectRatio;
const float ViewportWidth;
const float DeltaTime;

/**
 *	Compute and return the resultant 2D gravitational force between Target and AffectingBody.
 */
float3 CalculateGravitationalForce(uint TargetBodyID, uint AffectingBodyID)
{
	float Distance = distance(Positions[TargetBodyID], Positions[AffectingBodyID]);


	float3 Direction = Positions[AffectingBodyID] - Positions[TargetBodyID];
	Direction = normalize(Direction);


	/**
	 *	Since we do not handle collision, we cant really compute small distance force.
	 *	This would make some body to get super high acceleration.
	 *	We also avoid diving by zero.
	 */
	// Distance = max(Distance, 100.0f);

	
	float ForceMagnitude;

	if (0)
	{
		ForceMagnitude = GravityConstant * Masses[TargetBodyID] * Masses[AffectingBodyID] / (Distance * Distance);
	}
	else
	{
		ForceMagnitude = -0.1;
	}

	
	return Direction * ForceMagnitude;
}

[numthreads(256, 1, 1)]
void CalculateVelocitiesCS(uint3 ID : SV_DispatchThreadID)
{
	if (ID.x >= NumBodies) return;


	if (1)
	{
		
		float3 Acceleration= float3(0, 0, 0);

		for (uint i = 0; i < NumBodies; i++)
		{
			// Skip if self.
			if (i == ID.x) continue;

			float3 GravityForce = CalculateGravitationalForce(ID.x, i);


			if (0)
			{
				Acceleration += GravityForce / Masses[ID.x];
			}
			else
			{
				Acceleration += GravityForce;
			}
		}

		Velocities[ID.x] += Acceleration * DeltaTime;
		Positions[ID.x] += Velocities[ID.x] * DeltaTime;
	}
	else
	{
		float3 pos = Positions[ID.x];  // Read the current position
		pos += float3(1.0, 1.0,1.0);  // Increment each component by 1
		Positions[ID.x] = pos;  // Write it back to the buffer
	}

}
